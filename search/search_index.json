{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Single Digital Presence \u00b6 Warning Your are viewing a version of the documentation that is currently being developed. Some of the sections are missing or incomplete. The documentation will be versioned once it is ready Overview \u00b6 SDP project covers implementing a Drupal distribution to build a Content Store site containing site sections and providing content for semi-independent sites. It also covers providing of technical implementation to build fully independent sites. Info Example of Content Store site is https://vic.gov.au , which has site-sections such as Aboriginal Victoria or Family Violence. Semi-independent sites are the other sites that have their content centrally managed. An example of such site is the Office of the Victorian Government Architect site. Fully independent sites are completely separate installations of the whole distribution. Project goals \u00b6 Making it easier to find, understand and use Victorian Government information Bringing 50 websites onto one platform and providing a consistent user experience Simplifying and standardising publishing Providing user research and a user first approach Reducing cost Increasing security Benefits \u00b6 More consistent UX Improved Admin Interface Improved Security and Improvement process Cheaper, more scalable and performant hosting Cost savings across Govt Better Government (and community) collaboration Better Developer Experience","title":"About"},{"location":"#single-digital-presence","text":"Warning Your are viewing a version of the documentation that is currently being developed. Some of the sections are missing or incomplete. The documentation will be versioned once it is ready","title":"Single Digital Presence"},{"location":"#overview","text":"SDP project covers implementing a Drupal distribution to build a Content Store site containing site sections and providing content for semi-independent sites. It also covers providing of technical implementation to build fully independent sites. Info Example of Content Store site is https://vic.gov.au , which has site-sections such as Aboriginal Victoria or Family Violence. Semi-independent sites are the other sites that have their content centrally managed. An example of such site is the Office of the Victorian Government Architect site. Fully independent sites are completely separate installations of the whole distribution.","title":"Overview"},{"location":"#project-goals","text":"Making it easier to find, understand and use Victorian Government information Bringing 50 websites onto one platform and providing a consistent user experience Simplifying and standardising publishing Providing user research and a user first approach Reducing cost Increasing security","title":"Project goals"},{"location":"#benefits","text":"More consistent UX Improved Admin Interface Improved Security and Improvement process Cheaper, more scalable and performant hosting Cost savings across Govt Better Government (and community) collaboration Better Developer Experience","title":"Benefits"},{"location":"architecture/","text":"Architecture \u00b6 Single Digital Presence is a distribution that consists of content repository with exposed API (headless Drupal distribution called Tide ) and a front-end components library ( Vue.js with Nuxt server rendering framework called Ripple ) hosted on the latest generation hosting platform ( Kubernetes -based Docker container platform called Bay ). Note The two main requirements that have significant affect on the architecture were: Content sharing across multiple sites. Content syndication via API. Content Sharing is a common issue amongst larger organisation, however the solutions are highly complex and the publicly available options are not mature enough for immediate use. Application system components \u00b6 At the application layer, there are 2 main components of the system: Tide - Drupal 8 headless distribution that serves as a content repository. Ripple - Vue.js-based library of front-end components. Each instance of Ripple serves as a standalone front-end application for a website. System components inheritance \u00b6 There are 3 layer of components in the Distribution. The features provided by every layer contribute to a final particular website feature set. Each of the layers is owned, supported and maintained by a distinct community: - Open Source - provides Drupal core and contributed modules. It is maintained by a worldwide Drupal community. - Distribution - provides content types, multi-channel and API features. It is maintained by SDP development team. - Specific website - provides unique site features and design components. It is maintained by a particular website development team. See Tide and Ripple for more information about architecture. Content Sharing \u00b6 Content Editors author content and select content sharing targets (semi-independent sites and site sections) for each content piece. Drupal will then serve this content as data through API to each front-end consumer site, implemented as a separate front-end application. Content repository site has only a basic frontend and its IP restricted to a list of allowed IP addresses, so that content editors from designated offices could access the editorial interface. The API endpoints for the content repository site are accessible to the world over the same predefined domain (e.g., https://api.agency.gov.au ). There is no authentication for content consumers. All content editing for all sites is performed through the central content repository instance (e.g. https://content.agency.gov.au ). There are no restrictions for editing content between the various sites, allowing content editors to be used across sites to better utilise limited resources. Content Approvals are still restricted to ensure content is only published upon approval by relevant users. This ensures cross site changes do not go public without proper approval. All content changes are tracked, so users making changes to the wrong site can receive further training to prevent future mistakes.","title":"Architecture"},{"location":"architecture/#architecture","text":"Single Digital Presence is a distribution that consists of content repository with exposed API (headless Drupal distribution called Tide ) and a front-end components library ( Vue.js with Nuxt server rendering framework called Ripple ) hosted on the latest generation hosting platform ( Kubernetes -based Docker container platform called Bay ). Note The two main requirements that have significant affect on the architecture were: Content sharing across multiple sites. Content syndication via API. Content Sharing is a common issue amongst larger organisation, however the solutions are highly complex and the publicly available options are not mature enough for immediate use.","title":"Architecture"},{"location":"architecture/#application-system-components","text":"At the application layer, there are 2 main components of the system: Tide - Drupal 8 headless distribution that serves as a content repository. Ripple - Vue.js-based library of front-end components. Each instance of Ripple serves as a standalone front-end application for a website.","title":"Application system components"},{"location":"architecture/#system-components-inheritance","text":"There are 3 layer of components in the Distribution. The features provided by every layer contribute to a final particular website feature set. Each of the layers is owned, supported and maintained by a distinct community: - Open Source - provides Drupal core and contributed modules. It is maintained by a worldwide Drupal community. - Distribution - provides content types, multi-channel and API features. It is maintained by SDP development team. - Specific website - provides unique site features and design components. It is maintained by a particular website development team. See Tide and Ripple for more information about architecture.","title":"System components inheritance"},{"location":"architecture/#content-sharing","text":"Content Editors author content and select content sharing targets (semi-independent sites and site sections) for each content piece. Drupal will then serve this content as data through API to each front-end consumer site, implemented as a separate front-end application. Content repository site has only a basic frontend and its IP restricted to a list of allowed IP addresses, so that content editors from designated offices could access the editorial interface. The API endpoints for the content repository site are accessible to the world over the same predefined domain (e.g., https://api.agency.gov.au ). There is no authentication for content consumers. All content editing for all sites is performed through the central content repository instance (e.g. https://content.agency.gov.au ). There are no restrictions for editing content between the various sites, allowing content editors to be used across sites to better utilise limited resources. Content Approvals are still restricted to ensure content is only published upon approval by relevant users. This ensures cross site changes do not go public without proper approval. All content changes are tracked, so users making changes to the wrong site can receive further training to prevent future mistakes.","title":"Content Sharing"},{"location":"assets/README.module/","text":"name \u00b6 Page content type for Tide distribution for Drupal 8 Tide is a Drupal 8 distribution focused on delivering an API first, headless Drupal content administration site. What is in this package \u00b6 content type fields blocks views JSONAPI module integration Installation \u00b6 To install this package, add this custom repository to repositories section of your composer.json : { \"repositories\" : { \"dpc-sdp/tide_page\" : { \"type\" : \"vcs\" , \"no-api\" : true , \"url\" : \"https://github.com/dpc-sdp/tide_page.git\" } } } Require this package as any other Composer package: composer require dpc/tide_page Support \u00b6 Digital Engagement, Department of Premier and Cabinet, Victoria, Australia is a maintainer of this package. Contribute \u00b6 Open an issue on GitHub or submit a pull request with suggested changes. Development and maintenance \u00b6 Development is powered by Dev-Tools . Please refer to Dev-Tools' page for system requirements and other details. To start local development stack: 1. Checkout this project 2. Run ./dev-tools.sh 3. Run ahoy build Related projects \u00b6 tide tide_api tide_core tide_event tide_landing_page tide_media tide_monsido tide_news tide_page tide_search tide_site tide_test tide_webform License \u00b6 This project is licensed under GPL2","title":"_name_"},{"location":"assets/README.module/#name","text":"Page content type for Tide distribution for Drupal 8 Tide is a Drupal 8 distribution focused on delivering an API first, headless Drupal content administration site.","title":"name"},{"location":"assets/README.module/#what-is-in-this-package","text":"content type fields blocks views JSONAPI module integration","title":"What is in this package"},{"location":"assets/README.module/#installation","text":"To install this package, add this custom repository to repositories section of your composer.json : { \"repositories\" : { \"dpc-sdp/tide_page\" : { \"type\" : \"vcs\" , \"no-api\" : true , \"url\" : \"https://github.com/dpc-sdp/tide_page.git\" } } } Require this package as any other Composer package: composer require dpc/tide_page","title":"Installation"},{"location":"assets/README.module/#support","text":"Digital Engagement, Department of Premier and Cabinet, Victoria, Australia is a maintainer of this package.","title":"Support"},{"location":"assets/README.module/#contribute","text":"Open an issue on GitHub or submit a pull request with suggested changes.","title":"Contribute"},{"location":"assets/README.module/#development-and-maintenance","text":"Development is powered by Dev-Tools . Please refer to Dev-Tools' page for system requirements and other details. To start local development stack: 1. Checkout this project 2. Run ./dev-tools.sh 3. Run ahoy build","title":"Development and maintenance"},{"location":"assets/README.module/#related-projects","text":"tide tide_api tide_core tide_event tide_landing_page tide_media tide_monsido tide_news tide_page tide_search tide_site tide_test tide_webform","title":"Related projects"},{"location":"assets/README.module/#license","text":"This project is licensed under GPL2","title":"License"},{"location":"assets/README.site/","text":"name \u00b6 To be provided.","title":"_name_"},{"location":"assets/README.site/#name","text":"To be provided.","title":"name"},{"location":"bay/","text":"Bay \u00b6 Bay is a Kubernetes-based (OpenShift) Docker container hosting platform with auto-scaling, auto-recovery and high-availability at core. Bay is based on open-source project Lagoon . Quote Lagoon solves what developers are dreaming about: A system that allows developers to locally develop their code and their services with Docker and run the exact same system in production. The same Docker images, the same service configurations and the same code. The platform has several layers (from the bottom to the top): The AWS layer is how the platform is physically hosted. It is spread accross multiple data centers to allow auto-scaling, fault-tolerance and disaster recovery. The Kubernetes layer allows to automate deployment, scale, and manage containerized application. The OpenShift layer is a Kubernetes distribution with enterprise-grade features and support. The Bay layer is an orchestration tool used to bundle containers into projects and manage deployments. The Application layer is where Drupal, NodeJS and other types of application reside. Architecture overview \u00b6 An over-simplified Bay platform architecture overview: Requests coming from the Citizen to the load balancer and then get directed to the dedicated containers in specific data centre (not necessarily the same for all containers). These containers are provisioned, auto-scaled and auto-healed using Orchestration Tool Box. Developers have identical development stack installed locally. Automated builds in Continuous Integration servers use identical container images. In this way, all environments are running identical versions of languages, frameworks and libraries required for a particular website. Namespaces \u00b6 Docker vendor namespace: dpc_sdp Docker images namespace: * (service name) Repositories \u00b6 Bay source code: https://github.com/dpc-sdp/bay Quay: https://quay.io/organization/dpc_sdp","title":"Overview"},{"location":"bay/#bay","text":"Bay is a Kubernetes-based (OpenShift) Docker container hosting platform with auto-scaling, auto-recovery and high-availability at core. Bay is based on open-source project Lagoon . Quote Lagoon solves what developers are dreaming about: A system that allows developers to locally develop their code and their services with Docker and run the exact same system in production. The same Docker images, the same service configurations and the same code. The platform has several layers (from the bottom to the top): The AWS layer is how the platform is physically hosted. It is spread accross multiple data centers to allow auto-scaling, fault-tolerance and disaster recovery. The Kubernetes layer allows to automate deployment, scale, and manage containerized application. The OpenShift layer is a Kubernetes distribution with enterprise-grade features and support. The Bay layer is an orchestration tool used to bundle containers into projects and manage deployments. The Application layer is where Drupal, NodeJS and other types of application reside.","title":"Bay"},{"location":"bay/#architecture-overview","text":"An over-simplified Bay platform architecture overview: Requests coming from the Citizen to the load balancer and then get directed to the dedicated containers in specific data centre (not necessarily the same for all containers). These containers are provisioned, auto-scaled and auto-healed using Orchestration Tool Box. Developers have identical development stack installed locally. Automated builds in Continuous Integration servers use identical container images. In this way, all environments are running identical versions of languages, frameworks and libraries required for a particular website.","title":"Architecture overview"},{"location":"bay/#namespaces","text":"Docker vendor namespace: dpc_sdp Docker images namespace: * (service name)","title":"Namespaces"},{"location":"bay/#repositories","text":"Bay source code: https://github.com/dpc-sdp/bay Quay: https://quay.io/organization/dpc_sdp","title":"Repositories"},{"location":"bay/onboarding/","text":"Onboarding to Bay \u00b6 This chapter describes the process of onboarding to Bay: who to contact, what to provide, time frame.","title":"Onboarding"},{"location":"bay/onboarding/#onboarding-to-bay","text":"This chapter describes the process of onboarding to Bay: who to contact, what to provide, time frame.","title":"Onboarding to Bay"},{"location":"development/","text":"Development Overview \u00b6 Content for this page has not been migrated yet.","title":"Overview"},{"location":"development/#development-overview","text":"Content for this page has not been migrated yet.","title":"Development Overview"},{"location":"development/accessibility/","text":"Accessibility requirements \u00b6 Content for this page has not been migrated yet.","title":"Accessibility"},{"location":"development/accessibility/#accessibility-requirements","text":"Content for this page has not been migrated yet.","title":"Accessibility requirements"},{"location":"development/automated-builds/","text":"Automated builds \u00b6 Content for this page has not been migrated yet.","title":"Automated builds"},{"location":"development/automated-builds/#automated-builds","text":"Content for this page has not been migrated yet.","title":"Automated builds"},{"location":"development/back-end-coding-standards/","text":"Back-End Coding Standards \u00b6 PHP \u00b6 We use Drupal Coding Standards for all our contributed and custom modules. PHPCodeSniffer runs our code linting using rules from Drupal Coder module and additional customizations. See our the PHPCodeSniffer configuration file . Running locally ahoy lint Setting project coding standards in PHPStorm PHPStorm > Preferences > Code Style Select the appropriate language (in the example image below it is PHP ) Select the Set from... link Select Predefined Style > Drupal It is then possible to use the keyboard shortcut Alt + command + l to format a file or selection. Composer \u00b6 Alphabetise where possible This helps developers to visually scan code faster. Include information to make reviews easier Each patch attribute name should contain the title of the Drupal.org (d.o) issue, the link to the issue comment that contains the patch and the patch attribute value should be the patch file on drupal.org: \"drupal/project\" : { \"Issue title - https://www.drupal.org/node/1234567#12345678\" : \"https://www.drupal.org/files/issues/issue_title-1234567-2.patch\" } , Following this approach makes it simpler to follow up the status of patches during updates. Example of a properly formatted patches attribute: \"patches\" : { \"drupal/better_exposed_filters\" : { \"Add core/drupal as dependency to better_exposed_filters asset libraries - https://www.drupal.org/node/2902742\" : \"https://www.drupal.org/files/issues/add_core_drupal_as-2902742-2.patch\" }, \"drupal/core\" : { \"No validation on text length for menu description when editing node - https://www.drupal.org/node/2852665#comment-12157856\" : \"https://www.drupal.org/files/issues/fatal_error_remove_menu_add_with_tests-2852665-12.patch\" }, } ,","title":"Back-end coding standards"},{"location":"development/back-end-coding-standards/#back-end-coding-standards","text":"","title":"Back-End Coding Standards"},{"location":"development/back-end-coding-standards/#php","text":"We use Drupal Coding Standards for all our contributed and custom modules. PHPCodeSniffer runs our code linting using rules from Drupal Coder module and additional customizations. See our the PHPCodeSniffer configuration file .","title":"PHP"},{"location":"development/back-end-coding-standards/#composer","text":"Alphabetise where possible This helps developers to visually scan code faster. Include information to make reviews easier Each patch attribute name should contain the title of the Drupal.org (d.o) issue, the link to the issue comment that contains the patch and the patch attribute value should be the patch file on drupal.org: \"drupal/project\" : { \"Issue title - https://www.drupal.org/node/1234567#12345678\" : \"https://www.drupal.org/files/issues/issue_title-1234567-2.patch\" } , Following this approach makes it simpler to follow up the status of patches during updates. Example of a properly formatted patches attribute: \"patches\" : { \"drupal/better_exposed_filters\" : { \"Add core/drupal as dependency to better_exposed_filters asset libraries - https://www.drupal.org/node/2902742\" : \"https://www.drupal.org/files/issues/add_core_drupal_as-2902742-2.patch\" }, \"drupal/core\" : { \"No validation on text length for menu description when editing node - https://www.drupal.org/node/2852665#comment-12157856\" : \"https://www.drupal.org/files/issues/fatal_error_remove_menu_add_with_tests-2852665-12.patch\" }, } ,","title":"Composer"},{"location":"development/code-review/","text":"Code review \u00b6 Content for this page has not been migrated yet.","title":"Code review"},{"location":"development/code-review/#code-review","text":"Content for this page has not been migrated yet.","title":"Code review"},{"location":"development/compliance-vpdss/","text":"Compliance with VPDSS \u00b6 Content for this page has not been migrated yet.","title":"Compliance with VPDSS"},{"location":"development/compliance-vpdss/#compliance-with-vpdss","text":"Content for this page has not been migrated yet.","title":"Compliance with VPDSS"},{"location":"development/documentation/","text":"Documentation for SDP \u00b6 https://dpc-sdp.github.io/sdp-docs/ Requirements \u00b6 Docker Ahoy Quickstart \u00b6 To build locally: ahoy build To serve locally: ahoy deploy Available commands \u00b6 build Build site deploy Deploy site serve Serve site in browser version MkDocs version Automated deployment \u00b6 CircleCI is configured to perform automated deployments for the main branch. The built site is automatically pushed to gh-pages branch. Also note that built site is available in CircleCI build artifacts tab. Important! Do not commit to gh-pages branch manually. Also, try to avoid using ahoy deploy command. Maintenance \u00b6 SDP development team is a main maintainer of this documentation. We welcome contributions to this documentation! Please open an issue or submit a pull request.","title":"Maintaining this documentation"},{"location":"development/documentation/#documentation-for-sdp","text":"https://dpc-sdp.github.io/sdp-docs/","title":"Documentation for SDP"},{"location":"development/documentation/#requirements","text":"Docker Ahoy","title":"Requirements"},{"location":"development/documentation/#quickstart","text":"To build locally: ahoy build To serve locally: ahoy deploy","title":"Quickstart"},{"location":"development/documentation/#available-commands","text":"build Build site deploy Deploy site serve Serve site in browser version MkDocs version","title":"Available commands"},{"location":"development/documentation/#automated-deployment","text":"CircleCI is configured to perform automated deployments for the main branch. The built site is automatically pushed to gh-pages branch. Also note that built site is available in CircleCI build artifacts tab. Important! Do not commit to gh-pages branch manually. Also, try to avoid using ahoy deploy command.","title":"Automated deployment"},{"location":"development/documentation/#maintenance","text":"SDP development team is a main maintainer of this documentation. We welcome contributions to this documentation! Please open an issue or submit a pull request.","title":"Maintenance"},{"location":"development/front-end-coding-standards/","text":"Front-End Coding Standards \u00b6 Content for this page has not been migrated yet.","title":"Front-end coding standards"},{"location":"development/front-end-coding-standards/#front-end-coding-standards","text":"Content for this page has not been migrated yet.","title":"Front-End Coding Standards"},{"location":"development/git/","text":"Git \u00b6 Content for this page has not been migrated yet.","title":"Git"},{"location":"development/git/#git","text":"Content for this page has not been migrated yet.","title":"Git"},{"location":"development/local-development-environment/","text":"Local development environment \u00b6 Content for this page has not been migrated yet.","title":"Local development environment"},{"location":"development/local-development-environment/#local-development-environment","text":"Content for this page has not been migrated yet.","title":"Local development environment"},{"location":"development/module-development/","text":"Module development \u00b6 Content for this page has not been migrated yet.","title":"Module Development"},{"location":"development/module-development/#module-development","text":"Content for this page has not been migrated yet.","title":"Module development"},{"location":"development/nist-self-assessment/","text":"NIST self-assessment \u00b6 Content for this page has not been migrated yet.","title":"NIST self-assessment"},{"location":"development/nist-self-assessment/#nist-self-assessment","text":"Content for this page has not been migrated yet.","title":"NIST self-assessment"},{"location":"development/readme-files/","text":"README.md files \u00b6 We provide 2 templates of README.md files: for consumer projects and Tide modules. Projects \u00b6 # _name_ To be provided. Tide modules \u00b6 # _name_ Page content type for [Tide](https://github.com/dpc-sdp/tide) distribution for [Drupal 8](https://github.com/dpc-sdp) Tide is a Drupal 8 distribution focused on delivering an API first, headless Drupal content administration site. [![CircleCI](https://circleci.com/gh/dpc-sdp/_machine_name_.svg?style=shield&circle-token=2a0e49166724ac193636fba5b458024e00342dce)](https://circleci.com/gh/dpc-sdp/_machine_name_) [![Release](https://img.shields.io/github/release/dpc-sdp/_machine_name_.svg)](https://github.com/dpc-sdp/_machine_name_/releases/latest) ![https://www.drupal.org/8](https://img.shields.io/badge/Drupal-8-blue.svg) [![Licence: GPL 2](https://img.shields.io/badge/licence-GPL2-blue.svg)](https://github.com/dpc-sdp/_machine_name_/blob/master/LICENSE.txt) [![Pull Requests](https://img.shields.io/github/issues-pr/dpc-sdp/tide_page.svg)](https://github.com/dpc-sdp/_machine_name_/pulls) ## What is in this package - content type - fields - blocks - views - JSONAPI module integration ## Installation To install this package, add this custom repository to `repositories` section of your `composer.json`: ```json { \"repositories\": { \"dpc-sdp/tide_page\": { \"type\": \"vcs\", \"no-api\": true, \"url\": \"https://github.com/dpc-sdp/tide_page.git\" } } } ``` Require this package as any other Composer package: ```bash composer require dpc/tide_page ``` ## Support [Digital Engagement, Department of Premier and Cabinet, Victoria, Australia](https://github.com/dpc-sdp) is a maintainer of this package. ## Contribute [Open an issue](https://github.com/dpc-sdp) on GitHub or submit a pull request with suggested changes. ## Development and maintenance Development is powered by [Dev-Tools](https://github.com/dpc-sdp/dev-tools). Please refer to Dev-Tools' page for [system requirements](https://github.com/dpc-sdp/dev-tools/#prerequisites) and other details. To start local development stack: 1. Checkout this project 2. Run `./dev-tools.sh` 3. Run `ahoy build` ## Related projects - [tide](https://github.com/dpc-sdp/tide) - [tide_api](https://github.com/dpc-sdp/tide_api) - [tide_core](https://github.com/dpc-sdp/tide_core) - [tide_event](https://github.com/dpc-sdp/tide_event) - [tide_landing_page](https://github.com/dpc-sdp/tide_landing_page) - [tide_media](https://github.com/dpc-sdp/tide_media) - [tide_monsido](https://github.com/dpc-sdp/tide_monsido) - [tide_news](https://github.com/dpc-sdp/tide_news) - [tide_page](https://github.com/dpc-sdp/tide_page) - [tide_search](https://github.com/dpc-sdp/tide_search) - [tide_site](https://github.com/dpc-sdp/tide_site) - [tide_test](https://github.com/dpc-sdp/tide_test) - [tide_webform](https://github.com/dpc-sdp/tide_webform) ## License This project is licensed under [GPL2](https://github.com/dpc-sdp/_machine_name_/blob/master/LICENSE.txt)","title":"README.md files"},{"location":"development/readme-files/#readmemd-files","text":"We provide 2 templates of README.md files: for consumer projects and Tide modules.","title":"README.md files"},{"location":"development/readme-files/#projects","text":"# _name_ To be provided.","title":"Projects"},{"location":"development/readme-files/#tide-modules","text":"# _name_ Page content type for [Tide](https://github.com/dpc-sdp/tide) distribution for [Drupal 8](https://github.com/dpc-sdp) Tide is a Drupal 8 distribution focused on delivering an API first, headless Drupal content administration site. [![CircleCI](https://circleci.com/gh/dpc-sdp/_machine_name_.svg?style=shield&circle-token=2a0e49166724ac193636fba5b458024e00342dce)](https://circleci.com/gh/dpc-sdp/_machine_name_) [![Release](https://img.shields.io/github/release/dpc-sdp/_machine_name_.svg)](https://github.com/dpc-sdp/_machine_name_/releases/latest) ![https://www.drupal.org/8](https://img.shields.io/badge/Drupal-8-blue.svg) [![Licence: GPL 2](https://img.shields.io/badge/licence-GPL2-blue.svg)](https://github.com/dpc-sdp/_machine_name_/blob/master/LICENSE.txt) [![Pull Requests](https://img.shields.io/github/issues-pr/dpc-sdp/tide_page.svg)](https://github.com/dpc-sdp/_machine_name_/pulls) ## What is in this package - content type - fields - blocks - views - JSONAPI module integration ## Installation To install this package, add this custom repository to `repositories` section of your `composer.json`: ```json { \"repositories\": { \"dpc-sdp/tide_page\": { \"type\": \"vcs\", \"no-api\": true, \"url\": \"https://github.com/dpc-sdp/tide_page.git\" } } } ``` Require this package as any other Composer package: ```bash composer require dpc/tide_page ``` ## Support [Digital Engagement, Department of Premier and Cabinet, Victoria, Australia](https://github.com/dpc-sdp) is a maintainer of this package. ## Contribute [Open an issue](https://github.com/dpc-sdp) on GitHub or submit a pull request with suggested changes. ## Development and maintenance Development is powered by [Dev-Tools](https://github.com/dpc-sdp/dev-tools). Please refer to Dev-Tools' page for [system requirements](https://github.com/dpc-sdp/dev-tools/#prerequisites) and other details. To start local development stack: 1. Checkout this project 2. Run `./dev-tools.sh` 3. Run `ahoy build` ## Related projects - [tide](https://github.com/dpc-sdp/tide) - [tide_api](https://github.com/dpc-sdp/tide_api) - [tide_core](https://github.com/dpc-sdp/tide_core) - [tide_event](https://github.com/dpc-sdp/tide_event) - [tide_landing_page](https://github.com/dpc-sdp/tide_landing_page) - [tide_media](https://github.com/dpc-sdp/tide_media) - [tide_monsido](https://github.com/dpc-sdp/tide_monsido) - [tide_news](https://github.com/dpc-sdp/tide_news) - [tide_page](https://github.com/dpc-sdp/tide_page) - [tide_search](https://github.com/dpc-sdp/tide_search) - [tide_site](https://github.com/dpc-sdp/tide_site) - [tide_test](https://github.com/dpc-sdp/tide_test) - [tide_webform](https://github.com/dpc-sdp/tide_webform) ## License This project is licensed under [GPL2](https://github.com/dpc-sdp/_machine_name_/blob/master/LICENSE.txt)","title":"Tide modules"},{"location":"development/release/","text":"Managing releases \u00b6 Content for this page has not been migrated yet.","title":"Release management"},{"location":"development/release/#managing-releases","text":"Content for this page has not been migrated yet.","title":"Managing releases"},{"location":"development/troubleshooting/","text":"Troubleshooting \u00b6 Content for this page has not been migrated yet.","title":"Troubleshooting"},{"location":"development/troubleshooting/#troubleshooting","text":"Content for this page has not been migrated yet.","title":"Troubleshooting"},{"location":"development/workflow/","text":"Development workflow \u00b6 Content for this page has not been fully migrated yet. Example workflow \u00b6 This workflow describes working on features as a developer on websites that use Tide or Ripple. Pick a ticket in your issue tracker: Make sure that all requirements, solution direction and acceptance criteria are clear. If not, address issues with Technical Lead or product Owner. Assign to yourself. Create new feature branch named feature/CODE123-short-hyphenated-description . Work on the ticket functionality: Install new contributed modules or packages as required. For back-end - configure and export configuration changes; write hook_update_N() implementations (but be mindful that Drupal 8 does not require many of those). For front-end - identify and use existing or create new Ripple components; update styles according to style guide as required; make sure that Storybook has updated and new components added (it is important to always have style guide up to date). Add tests: For back-end - identify required Behat tests (only test your custom configuration, and critical user journeys; do not test Drupal's standard behaviour); identify and implement PHPUnit tests. For front-end - identify required tests and mocks, and implement them; add unit tests for any custom Nux functionality. Commit all changed and added files. Pay special attention to configuration files and their counterparts ( composer.json , composer.lock , package.json , package-lock.json ). Create a pull request in your issue tracker: Describe added/removed/changed functionality as a numerical list; add screenshots; comment your own code to explain places that may raise questions. Assign relevant review developers. Assign yourself as an owner of the pull request. Add a Needs review label (if does not exist - create one - helps to visually identify pull requests pending review). If your are using a messenger to communicate with your development team - copy and paste the link to the created pull request into messenger and ask for a review. Move the ticket in your issue tracker to In code review state (create this state if it does not exist to help identify tickets pending review).","title":"Development Workflow"},{"location":"development/workflow/#development-workflow","text":"Content for this page has not been fully migrated yet.","title":"Development workflow"},{"location":"development/workflow/#example-workflow","text":"This workflow describes working on features as a developer on websites that use Tide or Ripple. Pick a ticket in your issue tracker: Make sure that all requirements, solution direction and acceptance criteria are clear. If not, address issues with Technical Lead or product Owner. Assign to yourself. Create new feature branch named feature/CODE123-short-hyphenated-description . Work on the ticket functionality: Install new contributed modules or packages as required. For back-end - configure and export configuration changes; write hook_update_N() implementations (but be mindful that Drupal 8 does not require many of those). For front-end - identify and use existing or create new Ripple components; update styles according to style guide as required; make sure that Storybook has updated and new components added (it is important to always have style guide up to date). Add tests: For back-end - identify required Behat tests (only test your custom configuration, and critical user journeys; do not test Drupal's standard behaviour); identify and implement PHPUnit tests. For front-end - identify required tests and mocks, and implement them; add unit tests for any custom Nux functionality. Commit all changed and added files. Pay special attention to configuration files and their counterparts ( composer.json , composer.lock , package.json , package-lock.json ). Create a pull request in your issue tracker: Describe added/removed/changed functionality as a numerical list; add screenshots; comment your own code to explain places that may raise questions. Assign relevant review developers. Assign yourself as an owner of the pull request. Add a Needs review label (if does not exist - create one - helps to visually identify pull requests pending review). If your are using a messenger to communicate with your development team - copy and paste the link to the created pull request into messenger and ask for a review. Move the ticket in your issue tracker to In code review state (create this state if it does not exist to help identify tickets pending review).","title":"Example workflow"},{"location":"ripple/","text":"Ripple \u00b6 Content for this page has not been migrated yet. Namespaces \u00b6 NPM vendor namespace: dpc-sdp NPM packages namespace: ripple-* Repositories \u00b6 Ripple source code: https://github.com/dpc-sdp/ripple (this is a monorepo ). NPM: https://www.npmjs.com/org/dpc-sdp","title":"Overview"},{"location":"ripple/#ripple","text":"Content for this page has not been migrated yet.","title":"Ripple"},{"location":"ripple/#namespaces","text":"NPM vendor namespace: dpc-sdp NPM packages namespace: ripple-*","title":"Namespaces"},{"location":"ripple/#repositories","text":"Ripple source code: https://github.com/dpc-sdp/ripple (this is a monorepo ). NPM: https://www.npmjs.com/org/dpc-sdp","title":"Repositories"},{"location":"ripple/api/","text":"Ripple API \u00b6 Content for this page has not been migrated yet.","title":"API"},{"location":"ripple/api/#ripple-api","text":"Content for this page has not been migrated yet.","title":"Ripple API"},{"location":"ripple/components/","text":"Components \u00b6 Content for this page has not been migrated yet.","title":"Components"},{"location":"ripple/components/#components","text":"Content for this page has not been migrated yet.","title":"Components"},{"location":"ripple/content-rendering-pipeline/","text":"Content delivery and rendering pipeline \u00b6 Content for this page has not been migrated yet.","title":"Content rendering pipeline"},{"location":"ripple/content-rendering-pipeline/#content-delivery-and-rendering-pipeline","text":"Content for this page has not been migrated yet.","title":"Content delivery and rendering pipeline"},{"location":"ripple/search/","text":"Search \u00b6 Content for this page has not been migrated yet.","title":"Search"},{"location":"ripple/search/#search","text":"Content for this page has not been migrated yet.","title":"Search"},{"location":"ripple/setup/","text":"Setting up a new Ripple site \u00b6 Content for this page has not been migrated yet.","title":"Setup new site"},{"location":"ripple/setup/#setting-up-a-new-ripple-site","text":"Content for this page has not been migrated yet.","title":"Setting up a new Ripple site"},{"location":"tide/","text":"Tide \u00b6 Tide Drupal 8 distribution consists of a profile and several modules. The profile is a mere collection of Tide modules bundled into governed, stable and tested Drupal installation profile. All modules and a profile have automated tests to guarantee that a set of all modules at specified versions is always stable. Namespaces \u00b6 Composer vendor namespace: dpc-sdp Composer Drupal profile namespace: dpc-sdp/tide Composer Drupal modules namespace: tide_* . Drupal.org Drupal profile namespace: tide . Drupal.org Drupal modules namespace: tide_* . Drupal profile machine name: tide Drupal modules machine name: tide_* Repositories \u00b6 Drupal profile: https://github.com/dpc-sdp/tide Drupal custom modules: https://github.com/dpc-sdp/tide_api https://github.com/dpc-sdp/tide_core https://github.com/dpc-sdp/tide_event https://github.com/dpc-sdp/tide_landing_page https://github.com/dpc-sdp/tide_media https://github.com/dpc-sdp/tide_monsido https://github.com/dpc-sdp/tide_news https://github.com/dpc-sdp/tide_page https://github.com/dpc-sdp/tide_search https://github.com/dpc-sdp/tide_site https://github.com/dpc-sdp/tide_test https://github.com/dpc-sdp/tide_webform See Modules chapter for more information about modules.","title":"Overview"},{"location":"tide/#tide","text":"Tide Drupal 8 distribution consists of a profile and several modules. The profile is a mere collection of Tide modules bundled into governed, stable and tested Drupal installation profile. All modules and a profile have automated tests to guarantee that a set of all modules at specified versions is always stable.","title":"Tide"},{"location":"tide/#namespaces","text":"Composer vendor namespace: dpc-sdp Composer Drupal profile namespace: dpc-sdp/tide Composer Drupal modules namespace: tide_* . Drupal.org Drupal profile namespace: tide . Drupal.org Drupal modules namespace: tide_* . Drupal profile machine name: tide Drupal modules machine name: tide_*","title":"Namespaces"},{"location":"tide/#repositories","text":"Drupal profile: https://github.com/dpc-sdp/tide Drupal custom modules: https://github.com/dpc-sdp/tide_api https://github.com/dpc-sdp/tide_core https://github.com/dpc-sdp/tide_event https://github.com/dpc-sdp/tide_landing_page https://github.com/dpc-sdp/tide_media https://github.com/dpc-sdp/tide_monsido https://github.com/dpc-sdp/tide_news https://github.com/dpc-sdp/tide_page https://github.com/dpc-sdp/tide_search https://github.com/dpc-sdp/tide_site https://github.com/dpc-sdp/tide_test https://github.com/dpc-sdp/tide_webform See Modules chapter for more information about modules.","title":"Repositories"},{"location":"tide/api/","text":"Tide API \u00b6 Content API is built from a set of contributed modules and custom code provided through Tide API module. Why JSONAPI? \u00b6 Why we selected JSONAPI standard over generic REST provided by Drupal core: JSON is a standard of REST, a subset of generic REST rules. JSONAPI allows to query individual items and collections. Drupal JSONAPI module automatically exposes entities as endpoints. Because most of functionality is implement as entities in Drupal 8, there is no need for custom code to expose required features. JSONAPI is a newer format JSONAPI will be included in Drupal core. Documentation on using Drupal JSONAPI module: https://www.drupal .org/docs/8/modules/json-api It is assumed that API consumers support the following: Can traverse data. Can cache based on response headers. Can resolve relationships by following links. Drupal JSONAPI and related modules \u00b6 jsonapi - main module that exposes entities as endpoints and provides support for REST operations. jsonapi_extras - helper module to alter JSONAPI config: endpoints prefix (we are using /api/v1 ) and enable/disable endpoints for automatically exposed entities (we use this to limit access to internal entities). Endpoints \u00b6 Component Content API endpoint Comment 1 route /api/v1/route?alias=<alias> 2 main menu /api/v1/menu_link_content/menu_link_content?filter[menu_name][value]=main 3 banner TBD If exposed as a block - use block-based endpoint. If exposed as a content field - use entity endpoint with inclusion. 4 breadcrumbs TBD Not supported out of the box. May need to use main menu to build breadcrumbs by FEF. 5 content /api/v1/page/<UUID>?include=field_page_paragraph Can be combined with 6 6 related content /api/v1/page/<UUID>?include=field_related_content Can be combined with 5 7 share block /api/v1/block_content/share_block Content is static HTML 8 was this page helpful TBD Posting of webform submissions is not supported. Custom module may be required. 9 footer main menu /api/v1/menu_link_content/menu_link_content?filter[menu_name][value]=main 10 copyright /api/v1/block_content/copyright Content is static HTML 11 footer menu /api/v1/menu_link_content/menu_link_content?filter[menu_name][value]=footer 12 Sites information /api/v1/taxonomy_term/sites 13 Router /api/v1/router Alias lookup. May be required for ad-hoc queries from FEF. Page example that may use these endpoints Request flow \u00b6 The diagram below demonstrates how a single page is assembled by VueJS when hitting multiple endpoints. VueJS retrieves site information and caches it internally until the next cache clear. Each consumer site has only site UUID (taxonomy term UUID from Site vocabulary) hardcoded. The rest of configuration comes from taxonomy term: logo, slogan, footer text, main menu name, footer menu name. This information is later used in follow-up requests to retrieve relevant information. Content API Content , Content API Menu , and Content API Block are shown here as separated endpoints (they are indeed separate), but are handled by the same internal entity controller from JSONAPI Drupal module. The content is filtered by Content API Filter based on provided site and path query parameters. If no site or path is provided the request is considered invalid and an error response is returned. Content API Filter is a thin layer (e.g. request event listener) in front of all JSONAPI endpoints. For example, if the content exists, but is not assigned to a site or section, it is considered as non-existing content when accessed from this site. Internal Router is a mechanism to lookup internal path by provided alias. There is a similar functionality with a Router Endpoint , but it resolves aliases without additional Drupal-to-Drupal request. End-to-end URL resolution \u00b6 The diagram below describes how URL requested by a web browser is resolved by Drupal and served by VueJS. It covers both front-end and back-end mechanisms. To leverage JSONAPI module in Drupal, we are using API Router to resolve requested paths to a set of information about the route (UUID, content type, path, alias). This information then used by Client API path builder to assemble a path to then send a second request to the JSONAPI endpoint. It is important to note that due to how content links can be provided within content, the path resolution within API Router should be able to find the best match from either path or alias provided. For example, paths about-us , /about-us , node/123 , /node/123 should all resolve to UUID of About Us page. When matched entity found, API Router also checks if it has the specified site assigned and returns an error if this path is not available. Also, API Router has all lookups cached in Drupal's dynamic cache, which is tagged with cache tags (so that the cache for path is cleared when entity is updated). Router API endpoint \u00b6 To control content aliases from Drupal and resolve requests coming from Browser into FEF, a special Router endpoint exists to perform a lookup on provided path. Because the provided path can be either internal Drupal path or an alias, the lookup searches through all existing aliases and internal paths. When non-existing alias is provided, the endpoint returns an error according to JSONAPI specification. Router API also allows to filter by site if site URL query parameter is provided. Referenced entities \u00b6 JSONAPI supports including referenced entities in response by using include query parameter and a comma-separated list of entity reference fields. For example, /api/v1/page/<UUID>?include=field_page_paragraph . Drupal caching \u00b6 Response headers pass-through Drupal-generated cache tags.","title":"API"},{"location":"tide/api/#tide-api","text":"Content API is built from a set of contributed modules and custom code provided through Tide API module.","title":"Tide API"},{"location":"tide/api/#why-jsonapi","text":"Why we selected JSONAPI standard over generic REST provided by Drupal core: JSON is a standard of REST, a subset of generic REST rules. JSONAPI allows to query individual items and collections. Drupal JSONAPI module automatically exposes entities as endpoints. Because most of functionality is implement as entities in Drupal 8, there is no need for custom code to expose required features. JSONAPI is a newer format JSONAPI will be included in Drupal core. Documentation on using Drupal JSONAPI module: https://www.drupal .org/docs/8/modules/json-api It is assumed that API consumers support the following: Can traverse data. Can cache based on response headers. Can resolve relationships by following links.","title":"Why JSONAPI?"},{"location":"tide/api/#drupal-jsonapi-and-related-modules","text":"jsonapi - main module that exposes entities as endpoints and provides support for REST operations. jsonapi_extras - helper module to alter JSONAPI config: endpoints prefix (we are using /api/v1 ) and enable/disable endpoints for automatically exposed entities (we use this to limit access to internal entities).","title":"Drupal JSONAPI and related modules"},{"location":"tide/api/#endpoints","text":"Component Content API endpoint Comment 1 route /api/v1/route?alias=<alias> 2 main menu /api/v1/menu_link_content/menu_link_content?filter[menu_name][value]=main 3 banner TBD If exposed as a block - use block-based endpoint. If exposed as a content field - use entity endpoint with inclusion. 4 breadcrumbs TBD Not supported out of the box. May need to use main menu to build breadcrumbs by FEF. 5 content /api/v1/page/<UUID>?include=field_page_paragraph Can be combined with 6 6 related content /api/v1/page/<UUID>?include=field_related_content Can be combined with 5 7 share block /api/v1/block_content/share_block Content is static HTML 8 was this page helpful TBD Posting of webform submissions is not supported. Custom module may be required. 9 footer main menu /api/v1/menu_link_content/menu_link_content?filter[menu_name][value]=main 10 copyright /api/v1/block_content/copyright Content is static HTML 11 footer menu /api/v1/menu_link_content/menu_link_content?filter[menu_name][value]=footer 12 Sites information /api/v1/taxonomy_term/sites 13 Router /api/v1/router Alias lookup. May be required for ad-hoc queries from FEF. Page example that may use these endpoints","title":"Endpoints"},{"location":"tide/api/#request-flow","text":"The diagram below demonstrates how a single page is assembled by VueJS when hitting multiple endpoints. VueJS retrieves site information and caches it internally until the next cache clear. Each consumer site has only site UUID (taxonomy term UUID from Site vocabulary) hardcoded. The rest of configuration comes from taxonomy term: logo, slogan, footer text, main menu name, footer menu name. This information is later used in follow-up requests to retrieve relevant information. Content API Content , Content API Menu , and Content API Block are shown here as separated endpoints (they are indeed separate), but are handled by the same internal entity controller from JSONAPI Drupal module. The content is filtered by Content API Filter based on provided site and path query parameters. If no site or path is provided the request is considered invalid and an error response is returned. Content API Filter is a thin layer (e.g. request event listener) in front of all JSONAPI endpoints. For example, if the content exists, but is not assigned to a site or section, it is considered as non-existing content when accessed from this site. Internal Router is a mechanism to lookup internal path by provided alias. There is a similar functionality with a Router Endpoint , but it resolves aliases without additional Drupal-to-Drupal request.","title":"Request flow"},{"location":"tide/api/#end-to-end-url-resolution","text":"The diagram below describes how URL requested by a web browser is resolved by Drupal and served by VueJS. It covers both front-end and back-end mechanisms. To leverage JSONAPI module in Drupal, we are using API Router to resolve requested paths to a set of information about the route (UUID, content type, path, alias). This information then used by Client API path builder to assemble a path to then send a second request to the JSONAPI endpoint. It is important to note that due to how content links can be provided within content, the path resolution within API Router should be able to find the best match from either path or alias provided. For example, paths about-us , /about-us , node/123 , /node/123 should all resolve to UUID of About Us page. When matched entity found, API Router also checks if it has the specified site assigned and returns an error if this path is not available. Also, API Router has all lookups cached in Drupal's dynamic cache, which is tagged with cache tags (so that the cache for path is cleared when entity is updated).","title":"End-to-end URL resolution"},{"location":"tide/api/#router-api-endpoint","text":"To control content aliases from Drupal and resolve requests coming from Browser into FEF, a special Router endpoint exists to perform a lookup on provided path. Because the provided path can be either internal Drupal path or an alias, the lookup searches through all existing aliases and internal paths. When non-existing alias is provided, the endpoint returns an error according to JSONAPI specification. Router API also allows to filter by site if site URL query parameter is provided.","title":"Router API endpoint"},{"location":"tide/api/#referenced-entities","text":"JSONAPI supports including referenced entities in response by using include query parameter and a comma-separated list of entity reference fields. For example, /api/v1/page/<UUID>?include=field_page_paragraph .","title":"Referenced entities"},{"location":"tide/api/#drupal-caching","text":"Response headers pass-through Drupal-generated cache tags.","title":"Drupal caching"},{"location":"tide/fields-components/","text":"Fields and components \u00b6 Tide utilises Drupal fields within content types and other entities such as paragraphs and taxonomy terms. Concepts \u00b6 Fields are re-used between system components as much as possible. Fields names are kept to the minimum length. Fields always have a prefix that describes the entity or the feature they belong to. For example: field_page_intro_text is a Introductory text for Page content type. Fields configuration is bundled within Tide modules. Some fields are programmatically created when specific Tide modules are installed (for example, Tide Site creates 2 fields for each content type). Kinds of fields \u00b6 Content fields - used to capture and store content that is later exposed through API and consumed by the front-end. For example, Body or Summary fields. Flag (on/off) fields - used to enable/disable rendering of a pre-defined component/block/feature within front-end. For example, Show social links field that tells consumer front-end to show or hide Social links component. Reference fields - used to reference other content items. These are rendered in API as references; API consumers are expected to use ?include JSONAPI standard mechanism to include the contents of the referenced entity into the API response. For example, Cards components are paragraphs referenced from within the content type. Front-end must include paragraph name to retrieve required paragraph content. Cards \u00b6 Cards are front-end components that are implemented as paragraph items in Tide. Cards implemented as Paragraphs Cards are reusing fields storage (see the list of fields below). List of Card fields Name Machine name Type Title field_paragraph_title Text field Summary field_paragraph_summary Large multiline text field with WYSIWYG support Author field_paragraph_author Text field Media field_paragraph_media Media field Date field_paragraph_date Date field Link field_paragraph_link Link field List field_paragraph_list Entity reference Location field_paragraph_location Location/ Reference field_paragraph_reference Entity reference Topic field_paragraph_topic Entity reference Cards have 1-to-1 mapping to paragraphs. This means that: cards can be added/removed from/to consumer front-end websites and have their paragraphs counterparts created in Content repository mandatory state of the fields on cards is easier to configure and manage there is no need to manage any other 'types' of the same card (i.e. no special fields that would modify the 'type' of the card) Automated cards are using list entity reference field to reference items. Listing cards are comprised of paragraphs (for example, Key Dates paragraph will have a list of Event paragraphs). About Automated cards Automated cards are cards that source their content from a pre-defined mapping in the Content APU. For example, a card with a list of latest 3 events that automatically fetches only 3 latest events. Cards and paragraphs The table below describes how every Card component is represented with Tide paragraphs . Card Label (in Drupal) Machine name Fields (label, machine name) Comments Navigation featured (Manual) Navigation featured card_navigation_featured Title - field_paragraph_title Summary - field_paragraph_summary Image - field_paragraph_media Link - field_paragraph_link This card has 1 text link. Link text = Title Navigation featured (Automatic) Navigation featured Automated card_navigation_featured_auto Referred content - field_paragraph_reference This card has 1 text link. Link text = Title Navigation (Manual) Navigation card_navigation Title - field_paragraph_title Summary - field_paragraph_summary Link - field_paragraph_link This card has 1 text link. Link text = Title Navigation Automated Navigation Automated card_navigation_auto Referred content - field_paragraph_reference This card has 1 text link. Link text = Title Promotion (Manual) Promotion card_promotion Title - field_paragraph_title Summary - field_paragraph_summary Image - field_paragraph_media Date - field_paragraph_date Topic - field_paragraph_topic Link - field_paragraph_link This card has 3 text links. Link 1 = Title Link 2 = Topic Link 3 = Link Promotion Automated Promotion Automated card_promotion_auto Referred content - field_paragraph_reference This card has 3 text links. Link 1 = Title Link 2 = Topic Link 3 = Link Event (Manual) Event card_event Title - field_paragraph_title Summary - field_paragraph_summary Image - field_paragraph_media Date - field_paragraph_date Location - field_paragraph_location Topic - field_paragraph_topic Link - field_paragraph_link This card has 4 text links. Link 1 = Title Link 2 = Location Link 3 = Topic Link 4 = Link Key dates (Manual) Key dates card_keydates 1. Add a paragraph type Keydates (with fields): Key Dates - field_paragraph_keydate Title - field_paragraph_title Summary - field_paragraph_summary Link - field_paragraph_link 2. Add a paragraph type - Card Keydates Keydates - Entity Ref - Paragraph type created above - Max 2 values CTA - field_paragraph_cta This card has 3 text links. Link 1 = Link (Keydates 1) Link 2 = Link (Keydates 2) Link 3 = CTA","title":"Fields and components"},{"location":"tide/fields-components/#fields-and-components","text":"Tide utilises Drupal fields within content types and other entities such as paragraphs and taxonomy terms.","title":"Fields and components"},{"location":"tide/fields-components/#concepts","text":"Fields are re-used between system components as much as possible. Fields names are kept to the minimum length. Fields always have a prefix that describes the entity or the feature they belong to. For example: field_page_intro_text is a Introductory text for Page content type. Fields configuration is bundled within Tide modules. Some fields are programmatically created when specific Tide modules are installed (for example, Tide Site creates 2 fields for each content type).","title":"Concepts"},{"location":"tide/fields-components/#kinds-of-fields","text":"Content fields - used to capture and store content that is later exposed through API and consumed by the front-end. For example, Body or Summary fields. Flag (on/off) fields - used to enable/disable rendering of a pre-defined component/block/feature within front-end. For example, Show social links field that tells consumer front-end to show or hide Social links component. Reference fields - used to reference other content items. These are rendered in API as references; API consumers are expected to use ?include JSONAPI standard mechanism to include the contents of the referenced entity into the API response. For example, Cards components are paragraphs referenced from within the content type. Front-end must include paragraph name to retrieve required paragraph content.","title":"Kinds of fields"},{"location":"tide/fields-components/#cards","text":"Cards are front-end components that are implemented as paragraph items in Tide. Cards implemented as Paragraphs Cards are reusing fields storage (see the list of fields below). List of Card fields Name Machine name Type Title field_paragraph_title Text field Summary field_paragraph_summary Large multiline text field with WYSIWYG support Author field_paragraph_author Text field Media field_paragraph_media Media field Date field_paragraph_date Date field Link field_paragraph_link Link field List field_paragraph_list Entity reference Location field_paragraph_location Location/ Reference field_paragraph_reference Entity reference Topic field_paragraph_topic Entity reference Cards have 1-to-1 mapping to paragraphs. This means that: cards can be added/removed from/to consumer front-end websites and have their paragraphs counterparts created in Content repository mandatory state of the fields on cards is easier to configure and manage there is no need to manage any other 'types' of the same card (i.e. no special fields that would modify the 'type' of the card) Automated cards are using list entity reference field to reference items. Listing cards are comprised of paragraphs (for example, Key Dates paragraph will have a list of Event paragraphs). About Automated cards Automated cards are cards that source their content from a pre-defined mapping in the Content APU. For example, a card with a list of latest 3 events that automatically fetches only 3 latest events.","title":"Cards"},{"location":"tide/modules/","text":"Modules \u00b6 The standalone modules are split based on the features or functionality they provide. Modules can be installed as a part of the profile as well as a standalone (provided that other dependency modules installed as well). Every module implements a well-defined feature set. Modules are versioned. This allows for more granular approach when picking modules for particular site needs. Every module has a minimal dependency on other modules. Every module has a set of relevant automated tests. List of modules \u00b6 Name Machine name Category Repository Description Tide API tide_api Utility https://github.com/dpc-sdp/tide_api Exposes content entities to API endpoints. it is required for sites running headless. Tide Core tide_core Utility https://github.com/dpc-sdp/tide_core Configurations and settings for Tide distribution. Dependency module for any other Tide module. Tide Event tide_event Content type https://github.com/dpc-sdp/tide_event Event content type and fields. Tide Landing Page tide_landing_page Content type https://github.com/dpc-sdp/tide_landing_page \"Landing page content type with fields. Based on paragrpahs, it allows to create pages with complex layouts.\" Tide Media tide_media Utility https://github.com/dpc-sdp/tide_media Media types and configurations. Tide Monsido tide_monsido 3 rd party integration https://github.com/dpc-sdp/tide_monsido Integration with Monsido platform. Tide News tide_news Content type https://github.com/dpc-sdp/tide_news Event content type and fields. Tide Page tide_page Content type https://github.com/dpc-sdp/tide_page Page content type and fields. Tide Search tide_search Utility https://github.com/dpc-sdp/tide_search Search configurations and settings. Tide Site tide_site Utility https://github.com/dpc-sdp/tide_site Multi-site and multi-section content sharing. Tide Test tide_test Utility https://github.com/dpc-sdp/tide_test Test content type and helpers used to test other modules. Tide Webform tide_webform Utility https://github.com/dpc-sdp/tide_webform Forms supports such as Content Rating form. Automated testing \u00b6 Tide modules use PHPUnit and Behat for unit and integration/behavioural testing. The tests are running inside of the Continuous Integration pipeline provided by CircleCI . For every change pushed to the repository, CircleCI starts the build, where tests are running in 2 modes: normal and suggested . In normal mode the module is installed with it's required dependencies into freshly built Drupal site. Once installed, the tests will run and check that the configuration shipped with the module indeed works. In suggested mode, the module is installed with it's requires and optional dependencies. Once installed, the tests will run and check that the configuration shipped with the module indeed works and that it does not conflict with other optional modules. This \"double-testing\" is very powerful tool to keep configuration in releasable state. Versions \u00b6 Modules versions follow semantic versioning : Quote Given a version number MAJOR.MINOR.PATCH , increment the: MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards-compatible manner, and PATCH version when you make backwards-compatible bug fixes. Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format. With some Tide functionality heavily relying on specific Drupal core version, when features added and changed in MINOR Drupal core versions (like moving Media into Drupal core), Tide modules increment their MAJOR version when Drupal core or dependent contributed modules change their API. Since Tide modules functionality is built on top of Drupal core and contributed modules, it has to \"tighten\" versioning rules. Every Tide module has to increment the: - MAJOR version when Drupal core or contrib module has an API change. An example of this is moving Media into Drupal core in version 8.5 . - MINOR version when Tide module functionality is enhanced or when other dependent Tide module has it's API change (that would trigger own release). - PATCH version when there is a backwards-compatible bug fixes (no change from SemVer). SDP development team is committed to support development, maintain all Tide modules and follow versioning rules.","title":"Modules"},{"location":"tide/modules/#modules","text":"The standalone modules are split based on the features or functionality they provide. Modules can be installed as a part of the profile as well as a standalone (provided that other dependency modules installed as well). Every module implements a well-defined feature set. Modules are versioned. This allows for more granular approach when picking modules for particular site needs. Every module has a minimal dependency on other modules. Every module has a set of relevant automated tests.","title":"Modules"},{"location":"tide/modules/#list-of-modules","text":"Name Machine name Category Repository Description Tide API tide_api Utility https://github.com/dpc-sdp/tide_api Exposes content entities to API endpoints. it is required for sites running headless. Tide Core tide_core Utility https://github.com/dpc-sdp/tide_core Configurations and settings for Tide distribution. Dependency module for any other Tide module. Tide Event tide_event Content type https://github.com/dpc-sdp/tide_event Event content type and fields. Tide Landing Page tide_landing_page Content type https://github.com/dpc-sdp/tide_landing_page \"Landing page content type with fields. Based on paragrpahs, it allows to create pages with complex layouts.\" Tide Media tide_media Utility https://github.com/dpc-sdp/tide_media Media types and configurations. Tide Monsido tide_monsido 3 rd party integration https://github.com/dpc-sdp/tide_monsido Integration with Monsido platform. Tide News tide_news Content type https://github.com/dpc-sdp/tide_news Event content type and fields. Tide Page tide_page Content type https://github.com/dpc-sdp/tide_page Page content type and fields. Tide Search tide_search Utility https://github.com/dpc-sdp/tide_search Search configurations and settings. Tide Site tide_site Utility https://github.com/dpc-sdp/tide_site Multi-site and multi-section content sharing. Tide Test tide_test Utility https://github.com/dpc-sdp/tide_test Test content type and helpers used to test other modules. Tide Webform tide_webform Utility https://github.com/dpc-sdp/tide_webform Forms supports such as Content Rating form.","title":"List of modules"},{"location":"tide/modules/#automated-testing","text":"Tide modules use PHPUnit and Behat for unit and integration/behavioural testing. The tests are running inside of the Continuous Integration pipeline provided by CircleCI . For every change pushed to the repository, CircleCI starts the build, where tests are running in 2 modes: normal and suggested . In normal mode the module is installed with it's required dependencies into freshly built Drupal site. Once installed, the tests will run and check that the configuration shipped with the module indeed works. In suggested mode, the module is installed with it's requires and optional dependencies. Once installed, the tests will run and check that the configuration shipped with the module indeed works and that it does not conflict with other optional modules. This \"double-testing\" is very powerful tool to keep configuration in releasable state.","title":"Automated testing"},{"location":"tide/modules/#versions","text":"Modules versions follow semantic versioning : Quote Given a version number MAJOR.MINOR.PATCH , increment the: MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards-compatible manner, and PATCH version when you make backwards-compatible bug fixes. Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format. With some Tide functionality heavily relying on specific Drupal core version, when features added and changed in MINOR Drupal core versions (like moving Media into Drupal core), Tide modules increment their MAJOR version when Drupal core or dependent contributed modules change their API. Since Tide modules functionality is built on top of Drupal core and contributed modules, it has to \"tighten\" versioning rules. Every Tide module has to increment the: - MAJOR version when Drupal core or contrib module has an API change. An example of this is moving Media into Drupal core in version 8.5 . - MINOR version when Tide module functionality is enhanced or when other dependent Tide module has it's API change (that would trigger own release). - PATCH version when there is a backwards-compatible bug fixes (no change from SemVer). SDP development team is committed to support development, maintain all Tide modules and follow versioning rules.","title":"Versions"},{"location":"tide/setup/","text":"Setting up a new Content Repository \u00b6 Note This chapter describes how to setup Content Repository using whole Tide distribution with all Tide modules included. It does not cover setting up of Tide modules outside of the distribution. Setup \u00b6 Setting up Tide Content Repository is similar to setting up a Drupal site from any other contributed profile. Create drupal project. Using drupal-project composer create-project drupal-composer/drupal-project:8.x-dev some-dir --no-interaction Add Tide profile: composer require dpc-sdp/tide Commit scaffolding files. Install a site using drush site-install : drush site-install tide --db-url=mysql://user:pwd@localhost/db_name --site-name=Example --account-name=admin --account-pass=pwd Export the database and import it into your production database. Hosting on Bay \u00b6 Content repository can be hosted on Bay. See Onboarding to Bay chapter. Environments \u00b6 The diagram below describes recommended environments for efficient front-end and back-end development: Production front-end sites are connected to production Content repository where API is stable and content is live. This is standard environments for production sites. UAT front-end sites are connected to UAT Content repository, where API is stable and content is live, but changes are not public. These environments allow to work with a copy of the live content without exposing it to public, which is useful during new feature testing. Local, CI and Preview (per branch) environments are connected to API-DEV Content repository, where the latest API is still being developed and demonstrative-only but consistent content. This provides access to the latest API changes while developing new front-end or back-end functionality. Other content consumers under active development may connect to the API Content repository with stable API and demonstrative-only but consistent content. This allows predictable API behaviour and data, but without access to change it.","title":"Content repository setup"},{"location":"tide/setup/#setting-up-a-new-content-repository","text":"Note This chapter describes how to setup Content Repository using whole Tide distribution with all Tide modules included. It does not cover setting up of Tide modules outside of the distribution.","title":"Setting up a new Content Repository"},{"location":"tide/setup/#setup","text":"Setting up Tide Content Repository is similar to setting up a Drupal site from any other contributed profile. Create drupal project. Using drupal-project composer create-project drupal-composer/drupal-project:8.x-dev some-dir --no-interaction Add Tide profile: composer require dpc-sdp/tide Commit scaffolding files. Install a site using drush site-install : drush site-install tide --db-url=mysql://user:pwd@localhost/db_name --site-name=Example --account-name=admin --account-pass=pwd Export the database and import it into your production database.","title":"Setup"},{"location":"tide/setup/#hosting-on-bay","text":"Content repository can be hosted on Bay. See Onboarding to Bay chapter.","title":"Hosting on Bay"},{"location":"tide/setup/#environments","text":"The diagram below describes recommended environments for efficient front-end and back-end development: Production front-end sites are connected to production Content repository where API is stable and content is live. This is standard environments for production sites. UAT front-end sites are connected to UAT Content repository, where API is stable and content is live, but changes are not public. These environments allow to work with a copy of the live content without exposing it to public, which is useful during new feature testing. Local, CI and Preview (per branch) environments are connected to API-DEV Content repository, where the latest API is still being developed and demonstrative-only but consistent content. This provides access to the latest API changes while developing new front-end or back-end functionality. Other content consumers under active development may connect to the API Content repository with stable API and demonstrative-only but consistent content. This allows predictable API behaviour and data, but without access to change it.","title":"Environments"},{"location":"tide/sites-sections/","text":"Sites and sections \u00b6 Content repository supports multi-site and multi-section content publishing. This means that a content piece may be re-used several times on multiple sites and sections ( sections belong to sites ). Tide Site module provides an ability for Editor to publish content to selected sites and sections . How it works \u00b6 Sites and sections defined in a single vocabulary Sites with the maximum depth of 1, making root-level terms to become sites and terms of depth level 1 to become sections . The module has code to provide back-end validation to prevent creating of terms with depth more than 1. We decided to use Drupal taxonomy for sites and sections for multiple reasons: Taxonomy terms are fieldable entities. This means that consumer sites can extend per-site properties as required, exposing them to the API. Taxonomy terms support hierarchy, which helps to define site-section relationship, and, as a result of this, easily filter associated content by site. Taxonomy terms can be selected in UI using one of the existing contributed widgets. Taxonomy terms have full Token and Pathauto support, which makes it easy to use them for building content URLs based on IA. Taxonomy terms have full JSONAPI support and can be queried by consumer front-ends in the same way as any other entities. The concept of using taxonomy terms to group content is easy to grasp. Content may be shared between sites, but never between sections, as this would lead to the same content being served from different URLs, which is highly discouraged by search engines. To mitigate the problem when the same content is shared between different websites, a selection of Primary site is required, which will be used to generate canonical URL for the content piece. As a result, every content type has 2 fields created automatically: site and primary_site . Both fields are compulsory. Editors are expected to select destination site and section for each content piece. Site and Section Fields \u00b6 To provide site and section-specific information through API, every Site taxonomy term has a set of the following information fields: Field Description Domains Multiline plain text field to specify site domains. This is used by Ripple to match on the domain where the request is coming from. One domain per line. Wildcards supported. Title Text field to specify site title. Slogan Text field to specify site slogan. Logo File field to upload site logo. Footer message Text field with WYSIWYG support to specify site footer message. Main Menu Per-site and per-section menus may be helpful to build section-based navigation experience. Site admins may associate existing or create new menu with every site term. This is an entity reference field. Footer Menu Per-site and per-section menus may be helpful to build section-based navigation experience. Site admins may associate existing or create new menu with every site term. This is an entity reference field. Site menus \u00b6 Per-site and per-section menus may be helpful to build section-based navigation experience. They allow to provide custom menu items for specific sites and sections. Site menus automatically created when a new Site taxonomy term is created. Basically, instead of creating a site and then creating a menu on the separate screen, we automatically create and assign a menu for each site within the site creation screen by checking relevant checkbox on Site term ctreation page. Expand for Site menu creation flow diagram Multi-site URL rendering \u00b6 When content piece belongs to multiple sites or sections, it may have links to it from other content pieces of the current domain or other domains. Drupal has to render these links with correct domains as a part of url, so that front-end consumers could output these links as-is. For example, if we have: - 2 sites first.com and second.com - 2 pages page1 and page2 - page1 has a link to page2 - page1 belongs to first.com - page2 belongs to both first.com and second.com; the primary site is set to second.com When the visitor is on the page first.com/page1 and follows the link /page2 she should end up on first.com/page2 and not second.com/page2 . And if the visitor comes from Google search to page2 , she should end up at second.com/page2 , because second.com is a primary site for page2 . This is just an example of the part of the problem. There are more use-cases and they are explained below. For content exposed through API, the links may come from different places: - For link fields, this should be fairly straightforward: the user enters the link and we have an internal node id. - For links entered in WYSIWYG, we need to use the LinkIt module so that we can extract a node id. - For links entered in WYSIWYG within referenced entities (for example, field on the paragraph belonging to the page) the API output will contains the path alias. For all links presented to the user: - internal links should be rendered as a relative path. If the link is to a page available on the current site, either primary or not, render as relative link - external links (including links to other sites/section) should be rendered with an absolute path. For links within WYSIWYG, Drupal has to extract, analyse and replace links before rendering it through API. For this, we use an enhancer (special piece of code to manipulate content output before it is rendered through API) to scrape the content, then render the relevant link. Implementation details The content is extracted from the raw contents of WYSIWYG filed using Link Extractor . Link Extractor scans HTML and extracts all links. This happens before Drupal sanitizes WYSIWYG field output. Every extracted link is then passed to a Link Resolver . Link Resolver takes node id, loads up the path alias using some complex logic (see diagram below) and then swaps it within the href. Resolved URL is then passed to Link Replacer . Link Replacer replaces old extracted links with new resolved ones within contents of the WYSIWYG field. The processsed field contents is then passed to API for normal rendering. For links coming from Link fields, the above applies, but starting from Link Resolver (there is no HTML to extarct teh link from , so Link Extractor is not required). The following diagram describes URL processing and link resolution in detail.","title":"Sites and sections"},{"location":"tide/sites-sections/#sites-and-sections","text":"Content repository supports multi-site and multi-section content publishing. This means that a content piece may be re-used several times on multiple sites and sections ( sections belong to sites ). Tide Site module provides an ability for Editor to publish content to selected sites and sections .","title":"Sites and sections"},{"location":"tide/sites-sections/#how-it-works","text":"Sites and sections defined in a single vocabulary Sites with the maximum depth of 1, making root-level terms to become sites and terms of depth level 1 to become sections . The module has code to provide back-end validation to prevent creating of terms with depth more than 1. We decided to use Drupal taxonomy for sites and sections for multiple reasons: Taxonomy terms are fieldable entities. This means that consumer sites can extend per-site properties as required, exposing them to the API. Taxonomy terms support hierarchy, which helps to define site-section relationship, and, as a result of this, easily filter associated content by site. Taxonomy terms can be selected in UI using one of the existing contributed widgets. Taxonomy terms have full Token and Pathauto support, which makes it easy to use them for building content URLs based on IA. Taxonomy terms have full JSONAPI support and can be queried by consumer front-ends in the same way as any other entities. The concept of using taxonomy terms to group content is easy to grasp. Content may be shared between sites, but never between sections, as this would lead to the same content being served from different URLs, which is highly discouraged by search engines. To mitigate the problem when the same content is shared between different websites, a selection of Primary site is required, which will be used to generate canonical URL for the content piece. As a result, every content type has 2 fields created automatically: site and primary_site . Both fields are compulsory. Editors are expected to select destination site and section for each content piece.","title":"How it works"},{"location":"tide/sites-sections/#site-and-section-fields","text":"To provide site and section-specific information through API, every Site taxonomy term has a set of the following information fields: Field Description Domains Multiline plain text field to specify site domains. This is used by Ripple to match on the domain where the request is coming from. One domain per line. Wildcards supported. Title Text field to specify site title. Slogan Text field to specify site slogan. Logo File field to upload site logo. Footer message Text field with WYSIWYG support to specify site footer message. Main Menu Per-site and per-section menus may be helpful to build section-based navigation experience. Site admins may associate existing or create new menu with every site term. This is an entity reference field. Footer Menu Per-site and per-section menus may be helpful to build section-based navigation experience. Site admins may associate existing or create new menu with every site term. This is an entity reference field.","title":"Site and Section Fields"},{"location":"tide/sites-sections/#site-menus","text":"Per-site and per-section menus may be helpful to build section-based navigation experience. They allow to provide custom menu items for specific sites and sections. Site menus automatically created when a new Site taxonomy term is created. Basically, instead of creating a site and then creating a menu on the separate screen, we automatically create and assign a menu for each site within the site creation screen by checking relevant checkbox on Site term ctreation page. Expand for Site menu creation flow diagram","title":"Site menus"},{"location":"tide/sites-sections/#multi-site-url-rendering","text":"When content piece belongs to multiple sites or sections, it may have links to it from other content pieces of the current domain or other domains. Drupal has to render these links with correct domains as a part of url, so that front-end consumers could output these links as-is. For example, if we have: - 2 sites first.com and second.com - 2 pages page1 and page2 - page1 has a link to page2 - page1 belongs to first.com - page2 belongs to both first.com and second.com; the primary site is set to second.com When the visitor is on the page first.com/page1 and follows the link /page2 she should end up on first.com/page2 and not second.com/page2 . And if the visitor comes from Google search to page2 , she should end up at second.com/page2 , because second.com is a primary site for page2 . This is just an example of the part of the problem. There are more use-cases and they are explained below. For content exposed through API, the links may come from different places: - For link fields, this should be fairly straightforward: the user enters the link and we have an internal node id. - For links entered in WYSIWYG, we need to use the LinkIt module so that we can extract a node id. - For links entered in WYSIWYG within referenced entities (for example, field on the paragraph belonging to the page) the API output will contains the path alias. For all links presented to the user: - internal links should be rendered as a relative path. If the link is to a page available on the current site, either primary or not, render as relative link - external links (including links to other sites/section) should be rendered with an absolute path. For links within WYSIWYG, Drupal has to extract, analyse and replace links before rendering it through API. For this, we use an enhancer (special piece of code to manipulate content output before it is rendered through API) to scrape the content, then render the relevant link. Implementation details The content is extracted from the raw contents of WYSIWYG filed using Link Extractor . Link Extractor scans HTML and extracts all links. This happens before Drupal sanitizes WYSIWYG field output. Every extracted link is then passed to a Link Resolver . Link Resolver takes node id, loads up the path alias using some complex logic (see diagram below) and then swaps it within the href. Resolved URL is then passed to Link Replacer . Link Replacer replaces old extracted links with new resolved ones within contents of the WYSIWYG field. The processsed field contents is then passed to API for normal rendering. For links coming from Link fields, the above applies, but starting from Link Resolver (there is no HTML to extarct teh link from , so Link Extractor is not required). The following diagram describes URL processing and link resolution in detail.","title":"Multi-site URL rendering"}]}